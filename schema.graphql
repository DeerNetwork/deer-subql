type KVData @jsonField {
  key: String
  value: String
  type: String
}

type NftMetadata @jsonField {
  name: String
}


type Block @entity {
  id: ID!
  number: BigInt
  timestamp: Date
  parentHash: String
  specVersion: String
  stateRoot: String
  extrinsicRoot: String

  extrinsics: [Extrinsic] @derivedFrom(field: "block")
  events: [Event] @derivedFrom(field: "block")
}

type Extrinsic @entity {
  id: ID!

  method: String
  section: String
  args: [KVData]
  signer: Account
  nonce: BigInt
  timestamp: Date
  signature: String
  tip: String
  isSigned: Boolean
  isSuccess: Boolean

  block: Block
  events: [Event] @derivedFrom(field: "extrinsic")
  calls: [Call] @derivedFrom(field: "extrinsic")
}

type Call @entity {
  id: ID!

  section: String
  method: String
  args:[KVData]
  timestamp: Date
  isSuccess: Boolean

  signer: Account
  extrinsic: Extrinsic
  parentCall: Call

  calls: [Call] @derivedFrom(field: "parentCall")
}

type Event @entity {
  id: ID!

  index: Int
  section: String
  method: String
  data: [KVData]

  timestamp: Date
  blockNumber: BigInt
  block: Block
  extrinsic: Extrinsic
}

type Account @entity {
  id: ID!

  txCount: BigInt
  createAtBlock: Block

  extrinsics: [Extrinsic] @derivedFrom(field: "signer")
  calls: [Call] @derivedFrom(field: "signer")
}

type Transfer @entity {
  id: ID!

  from: Account
  to: Account
  amount: BigInt

  extrinsic: Extrinsic
  timestamp: Date
}

type NftClass @entity {
  id: ID!

  owner: Account

  deposit: BigInt
  permission: Int
  metadata: NftMetadata
  metadataRaw: String
  totalTokens: BigInt
  totalIssuance: BigInt
  royaltyRate: Float
}

type NftToken @entity {
  id: ID!

  class: NftClass
  creator: Account

  localTokenId: String
  metadata: NftMetadata
  metadataRaw: String
  deposit: BigInt
  quantity: BigInt
  royaltyRate: Float
  royaltyBeneficiary: String

  owners: [NftTokenOwner] @derivedFrom(field: "token")
  burns: [NftTokenBurn] @derivedFrom(field: "token")
  transfers: [NftTokenTransfer] @derivedFrom(field: "token")
  orders: [NftOrder] @derivedFrom(field: "token")
  offers: [NftOffer] @derivedFrom(field: "token")
  auctions: [NftAuction] @derivedFrom(field: "token")
}


type NftTokenOwner @entity {
  id: ID!

  owner: Account
  token: NftToken

  free: BigInt
  reserved: BigInt
}

type NftTokenBurn @entity {
  id: ID!

  owner: Account
  token: NftToken

  quantity: BigInt

  extrinsic: Extrinsic
  timestamp: Date
}

type NftTokenTransfer @entity {
  id: ID!

  token: NftToken
  from: Account
  to: Account

  quantity: BigInt
  reason: String

  extrinsic: Extrinsic
  timestamp: Date
}

type NftAuction @entity {
  id: ID!

  creator: Account
  token: NftToken
  currentBid: NftAuctionBid

  status: NftAuctionStatus

  kind: NftAuctionKind

  quantity: BigInt
  mixPrice: BigInt
  maxPrice: BigInt
  initPrice: BigInt
  minRaisePrice: BigInt
  deposit: BigInt
  openAt: BigInt
  deadline: BigInt
}

enum NftAuctionKind {
  DUTCH
  ENGLISH
}

enum NftAuctionStatus {
  NORMAL
  CANCEL
  REDEEM
}

type NftAuctionBid @entity {
  id: ID!

  bidder: Account
  token: NftToken

  price: BigInt
  bidAt: BigInt

  extrinsic: Extrinsic
  timestamp: Date
}

type NftOrder @entity {
  id: ID!

  creator: Account
  token: NftToken

  price: BigInt
  deposit: BigInt
  deadline: BigInt
  totalQuantity: BigInt
  quantity: BigInt

  status: NftOrderStatus
}

enum NftOrderStatus {
  NORMAL
  CANCEL
  PARTIAL_DEAL
  PARTIAL_CANCEL
  FULL_DEAIL
}

type NftOrderDeal @entity {
  id: ID!

  buyer: Account
  token: NftToken
  order: NftOrder

  quantity: BigInt
  fee: BigInt

  extrinsic: Extrinsic
  timestamp: Date
}

type NftOffer @entity {
  id: ID!

  creator: Account
  token: NftToken

  quantity: BigInt
  price: BigInt
  deadline: BigInt

  status: NftOfferStatus
}

enum NftOfferStatus {
  NORMAL
  CANCEL
  DEAL
}

type StorageStoreFile @entity {
  id: ID!

  reserved: BigInt
  baseFee: BigInt
  addedAt: BigInt
  fileSize: BigInt
  firstAddedAt: BigInt
  status: StorageFileStatus

  currentOrderId: String
  founds: [StorageStoreFileFund] @derivedFrom(field: "storeFile")
  orders: [StorageFileOrder] @derivedFrom(field: "storeFile")
  replicas: [StorageFileOrderReplica] @derivedFrom(field: "storeFile")
}

enum StorageFileStatus {
  WAITING
  STORING
  INVALID
}

type StorageStoreFileFund @entity {
  id: ID!

  fee: BigInt 
  storeFile: StorageStoreFile
  funder: Account

  extrinsic: Extrinsic
  timestamp: Date
}

type StorageFileOrder @entity {
  id: ID!

  fee: BigInt
  fileSize: BigInt
  expireAt: BigInt
  addedAt: BigInt
  deletedAt: BigInt

  storeFile: StorageStoreFile
  replicas: [StorageFileOrderReplica] @derivedFrom(field: "order")
}

type StorageNode @entity {
  id: ID!

  owner: Account
  stasher: Account
  enclave: String
  deposit: BigInt
  rid: Int
  used: BigInt
  power: BigInt
  reportedAt: BigInt

  reports: [StorageNodeReport] @derivedFrom(field: "node")
  replicas: [StorageFileOrderReplica] @derivedFrom(field: "node")
}


type StorageFileOrderReplica @entity {
  id: ID!

  addedAt: BigInt
  deletedAt: BigInt

  node: StorageNode
  order: StorageFileOrder
  storeFile: StorageStoreFile
}

type StorageReportRound @entity {
  id: ID!

  used: BigInt
  power: BigInt
  mineReward: BigInt
  storeReward: BigInt
  paidMineReard: BigInt
  paidStoreReward: BigInt
  unpaid: BigInt
  endedAt: BigInt

  reports: [StorageNodeReport] @derivedFrom(field: "round")
}

type StorageNodeReport @entity {
  id: ID!

  node: StorageNode
  round: StorageReportRound

  rid: Int
  used: BigInt
  power: BigInt
  mineReward: BigInt
  shareStoreReward: BigInt
  directStoreReward: BigInt
  slash: BigInt

  extrinsic: Extrinsic
  timestamp: Date
}